package tregression.autofeedback;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.swt.widgets.Display;

import microbat.model.trace.Trace;
import microbat.model.trace.TraceNode;
import microbat.model.value.VarValue;
import microbat.model.variable.VirtualVar;
import microbat.recommendation.ChosenVariableOption;
import microbat.recommendation.UserFeedback;
import microbat.views.DebugFeedbackView;
import microbat.views.MicroBatViews;
import tregression.StepChangeType;
import tregression.StepChangeTypeChecker;
import tregression.handler.PlayRegressionLocalizationHandler;
import tregression.views.BuggyTraceView;
import tregression.views.CorrectTraceView;

/**
 * Feedback Generator is used to generated feedback based on the given method
 * @author David
 */
public abstract class FeedbackGenerator {
	
	/**
	 * Trace that the target node belongs to
	 */
	protected Trace trace;
	
	/**
	 * Method that is chosen to generate feedback.
	 */
	protected AutoFeedbackMethod selectedMethod;
	
	/**
	 * Feedback obtained from the microbat view
	 */
	protected UserFeedback feedbackFromView = null;
	
	/**
	 * If true, then generator will print the debug message.
	 */
	protected boolean isVerbal = false;
	
	/**
	 * Get the correspondence feedback generator based on the selected method
	 * @param trace
	 * @param method
	 * @return
	 */
	public static FeedbackGenerator getFeedbackGenerator(Trace trace, AutoFeedbackMethod method) {
		switch(method) {
		case NAIVE_CONTROL:
			return new NaiveFeedbackGenerator(trace, method, UserFeedback.WRONG_PATH);
		case RANDOM:
			return new RandomFeedbackGenerator(trace, method);
		case NAIVE_DATA:
			return new NaiveFeedbackGenerator(trace, method, UserFeedback.WRONG_VARIABLE_VALUE);
		default:
			return null;
		}
	}
	
	public FeedbackGenerator(Trace trace, AutoFeedbackMethod method) {
		this.trace = trace;
		this.selectedMethod = method;
	}
	
	/**
	 * Set verbal to true will allow debug message to print out
	 * @param verbal True then debug message is printed out
	 */
	public void setVerbal(boolean verbal) {
		this.isVerbal = verbal;
	}
	
	/**
	 * Notify the generator that the debugging process is end.
	 * Currently designed to end the server, which is used in ML approach
	 */
	public void notifyEnd() {}
	
	/**
	 * Give feedback for the give trace node based on the selected method
	 * @param node Target node
	 * @return Feedback of the given node
	 */
	abstract public UserFeedback giveFeedback(TraceNode node);
	
	/**
	 * Get the selected method
	 * @return Selected method
	 */
	public AutoFeedbackMethod getMethod() {
		return this.selectedMethod;
	}
	
	/**
	 * Request human feedback as ground truth. By now, this method will extract the feedback from tregression
	 * @param node	Target node
	 * @param buggyView	Tregression buggy view
	 * @param correctView Tregression correct view
	 * @return Ground Truth feedback
	 */
	public UserFeedback requestUserFeedback(TraceNode node, BuggyTraceView buggyView, CorrectTraceView correctView) {

		if (PlayRegressionLocalizationHandler.finder == null) {
			System.out.println("FeedbackGenerator error: finder is null");
			return null;
		}
		
		Trace buggyTrace = buggyView.getTrace();
		Trace correctTrace = correctView.getTrace();
		StepChangeTypeChecker typeChecker = new StepChangeTypeChecker(buggyTrace, correctTrace);

		StepChangeType type = typeChecker.getType(node, true, buggyView.getPairList(), buggyView.getDiffMatcher());
		UserFeedback feedback = new UserFeedback();
		switch(type.getType()) {
		case StepChangeType.IDT:
			feedback.setFeedbackType(UserFeedback.CORRECT);
			break;
		case StepChangeType.CTL:
			feedback.setFeedbackType(UserFeedback.WRONG_PATH);
			break;
		case StepChangeType.DAT:
			feedback.setFeedbackType(UserFeedback.WRONG_VARIABLE_VALUE);
			VarValue wrongVar = type.getWrongVariable(node, true, PlayRegressionLocalizationHandler.finder);
			feedback.setOption(new ChosenVariableOption(wrongVar, null));
			break;
		case StepChangeType.SRC:
			feedback.setFeedbackType(UserFeedback.UNCLEAR);
			break;
		}
		return feedback;
	}
	
//	/**
//	 * Remove the variables generated by Java from list
//	 * @param vars Input variable list
//	 * @return List of variable without variable generated by Java
//	 */
//	protected List<VarValue> removeVarsGenByJava(List<VarValue> input) {
//		// Deep copy
//		List<VarValue> vars = new ArrayList<VarValue>();
//		vars.addAll(input);
//		
//		// Do not count the temporary variable generated by java
//		for (int i=0; i<vars.size(); ++i) {
//			VarValue var = vars.get(i);
//			String var_id = var.getVarID();
//			if(var_id.startsWith("java.")) {
//				vars.remove(i);
//				i--;
//			}
//		}
//		return vars;
//	}
	
	/**
	 * Pick a random variable form give list of variable
	 * @param vars	List of variable
	 * @param bias	If true, then variable will prefer to pick the variable that is return from a function call
	 * @return Selected variable from list
	 */
	protected VarValue getRandVar(List<VarValue> vars, boolean bias) {
		if (bias) {
			for(VarValue var: vars) {
				// If the variable is returned from function call, then it is the instance of VirtualVar
				if(var.getVariable() instanceof VirtualVar) {
					if(Math.random() > 0.2) {
						return var;
					}
				}
			}
		}
		int wrongVarIdx = this.getRandomInt(0, vars.size());
		return vars.get(wrongVarIdx);
	}
	
	/**
	 * Get random integer
	 * @param min Lower bound
	 * @param max Upper bound
	 * @return Random integer in range [min, max)
	 */
	protected int getRandomInt(int min, int max) {
		return (int) ((Math.random() * (max - min)) + min);
	}
	
	protected UserFeedback genCIFeedback() {
		return new UserFeedback(UserFeedback.WRONG_PATH);
	}
	
	protected UserFeedback genCorrectFeedback() {
		return new UserFeedback(UserFeedback.CORRECT);
	}
	
	protected UserFeedback genDIFeedback(VarValue readVar, VarValue writeVar) {
		UserFeedback feedback = new UserFeedback(UserFeedback.WRONG_VARIABLE_VALUE);
		ChosenVariableOption option = new ChosenVariableOption(readVar, writeVar);
		feedback.setOption(option);
		return feedback;
	}
	
	protected UserFeedback genRandDIFeedback(TraceNode node) {
		VarValue wrongVar = this.getRandVar(node.getReadVariables(), false);
		return this.genDIFeedback(wrongVar, null);
	}
	
	protected UserFeedback genUnclearFeedback() {
		return new UserFeedback(UserFeedback.UNCLEAR);
	}
	
//	/**
//	 * Extract the feedback from feedback view of microbat, and then store it in feedbackFromView.
//	 */
//	protected void updateFeedbackFromView() {
//		Display.getDefault().syncExec(new Runnable() {
//			@Override
//			public void run() {
//				DebugFeedbackView feedbackView = MicroBatViews.getDebugFeedbackView();
//				UserFeedback feedback = feedbackView.getFeedback();
//				feedbackFromView = feedback;
//			}
//		});
//	}
	
	protected void printFeedbackMessage(TraceNode node, UserFeedback feedback) {
		if (!this.isVerbal) {
			return;
		}
		
		if (feedback == null) {
			System.out.println("For node: " + node.getOrder() + ", no feedback can be given");
			return;
		}
		
		switch(feedback.getFeedbackType()) {
		case UserFeedback.CORRECT:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is correct.");
			return;
		case UserFeedback.WRONG_PATH:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is control incorrect.");
			return;
		case UserFeedback.WRONG_VARIABLE_VALUE:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is data incorrect with wrong variable " + feedback.getOption().getReadVar().getVarName());
			return;
		case UserFeedback.UNCLEAR:
			System.out.println(this.selectedMethod.name() + ": This trace node " + node.getOrder() + " is unclear");
			return;
			default:
				return;
		}
	}
}